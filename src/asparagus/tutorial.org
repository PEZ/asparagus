* Introduction

Asparagus is my last experience in language design.
after several attempt, i've compiled some of the ideas I like, found in other languages/books/papers

It is embedded in clojure, but at the same time is quite far from it.
It has its own environment/namespaces mecanism, and another kind of macro system.
It is far from being production ready, but I hope that it can be interesting as an experiment for some of you.

I'm an autodidact with no proper computer science degree, my approch to programming is quite empirical.
First of all I'm seeking for feedback, advices, discussions and even people to work with (and I'm also searching for a real job!)

For now the main goals are: 

- flexibility
- extensibility
- expressivity
- performance (close to clojure)

The main ways/devices to acheive them:

- (environment/expansion)-passing-style macros (a more general/powerful macro system)
- pattern matching (built in to lambdas and binding-forms, extensible binding semantics)
- functional control flow (heavy use of function composition and guards, nil based shortcuiting constructs)
- generic functions at heart (all core operations of the language will be implementable by user types and implemented meaningfully by core types)
- holy datastructures's litterals (maps, vecs, lists and sets) at the heart (giving them more usages and extra syntax sugar)

This tutorial assumes familiarity with clojure. or at least another Lisp.

In order to be able to evaluate the forms contained in this file,
You should start a REPL and load asparagus.core.

#+begin_src clojure
(in-ns 'asparagus.core)
#+end_src

* Environment

The asparagus environment is holded by the `asparagus.core/E` atom

#+begin_src clojure
@E
#+end_src

** simple defintions

You can define a variable like this (=E+= stands for extend-environment).
Its like a really (really!) fancy =def=

#+begin_src clojure 
(E+ foo 1)
#+end_src

Or several at once

#+begin_src clojure 
(E+ bar \a
    baz 42)
#+end_src

For now we will use =!!= macro to evaluate forms (it is kind of ugly...), but later it will no longer be needed.

#+begin_src clojure 
(!! foo) ;; return the value under foo e.g 1
#+end_src

The =is= macro just assert equality of its arguments.

#+begin_src clojure 
(is 1 foo)
(is 42 baz)
(is \a bar)
#+end_src

You can modularize definitions (one of the motivational point of all this).
Here we use a hashmap literal to define several variables in 'mymodule and 'mymodule.c

#+begin_src clojure 
(E+ mymodule
    {a 1
     b "hey"
     c {d 42
        e :pouet}})
#+end_src

We can achieve the same with vector litteral syntax.
The semantic difference between hash and vec literals will be explained later.

#+begin_src clojure 
(E+ mymodule
    [a 1
     b "hey"
     c [d 42
        e :pouet]])
#+end_src

We use dot notation to access nested environment members

#+begin_src clojure 
(is 43
    (add mymodule.a mymodule.c.d)) ;; will add 1 and 42
#+end_src

Dot notation can be used in definitions too

#+begin_src clojure 
(E+ mymodule.c.f 2
    foo.bar 'foob)
#+end_src

This definition does not overide our previous ones, =foo= is still defined.

#+begin_src clojure 
(is 1 foo)
(is 'foob foo.bar)
#+end_src

One handy usage of this behavior is scoped helpers definition.

#+begin_src clojure 
(E+

 ;; our intent is to implement a stat function that takes any number of numeric arguments and return a map holding some statistics

 ;; first we are defining some helpers, that will be scoped under the stats identifier
 stats.sum
 (fn [xs] (apl add xs))
 stats.mean
 (fn [xs] (div (stats.sum xs) (count xs)))

 ;; then we are defining the main implementation with the help of the above definitions
 stats
 (fn [& xs]
   {:xs xs
    :sum (stats.sum xs)
    :mean (stats.mean xs)}))
#+end_src

In my clojure practice I was often annoyed to put stats.sum and stats.mean at the same level than stats.
Certainly I can create a stats namespace holding those helpers, but... it seems heavy for such a common/natural thing...

#+begin_src clojure 
(is (stats 1 2 3 4)
    {:xs '(1 2 3 4), :sum 10, :mean 5/2})
#+end_src

It could be defined with a map literal too.

#+begin_src clojure 
(E+ stats
    {;; for now i've hidden an important detail,
     ;; each identifier can have any number of what we will call attributes (or meta-keys, not really sure about the naming yet...)
     ;; attributes are stored and accessible using clojure keywords
     ;; for instance an identifier 'foo can have an attribute :size
     ;; it would be defined like this (E+ foo:size 3) and accessed like this 'foo:size, simple enough...

     ;; one of those attributes, that is systematically used under the hood is the :val attribute
     ;; :val hold the main value of the current identifier (here 'stats)
     ;; if the identifier 'stats' appears as is in the code this is the value we are refering to

     ;; note that the sum and mean helpers function (defined after) are available
     ;; when using map literal for definition, all members are available to each others
     :val
     (fn [& xs]
       {:xs xs
        :sum (.sum xs) ;; relative access, more on this later...
        :mean (.mean xs)
        })

     ;; helper submodules
     sum
     (fn [xs] (apl add xs))
     mean
     (fn [xs] (div (..sum xs) (count xs)))})
#+end_src

The =:val= thing is implicit in most cases.
Those three forms are equivalent:

#+begin_src clojure 
(E+ myval {:val 1})
(E+ myval:val 1)
(E+ myval 1)
#+end_src

Any environment variable can have any number of those attributes.

#+begin_src clojure 
(E+ stats
    {:doc "a functions that takes some numbers and do some statistics on it"
     :version 0.1
     :tags #{:math}
     :foo :bar})
#+end_src

They can be refered in code with colon notation.

#+begin_src clojure 
(is stats:doc
    "a functions that takes some numbers and do some statistics on it")

(is stats stats:val)
#+end_src

We also could have used vector syntax to define stats.

#+begin_src clojure 
(E+ stats
    [;; in vector literal definitions occurs sequentially
     ;; so we have to define helpers before 
     sum
     (fn [xs] (apl add xs))
     mean
     (fn [xs] (div (..sum xs) (count xs))) ;; once again ..sum is relative environment access, more later

     ;; here the :val of stats (the :val keyword can be omitted)
     (fn [& xs]
       {:xs xs
        :sum (.sum xs)
        :mean (.mean xs)})])
#+end_src

In =E+=, top level's strings literals represent documentation (a bold choice maybe...).
But I've said to myself, maybe hardcoded string in code are not so common? (at least at the top level) far less than keywords for instance.

#+begin_src clojure 
(E+ myvar
    ["myvar doc" 42])

;;  is equivalent to
(E+ myvar {:val 42 :doc "myvar doc"})

(is  "myvar doc"
     myvar:doc)
#+end_src

Finally we can redefine stats with doc litterals.

#+begin_src clojure 
(E+ stats
    [sum
     (fn [xs] (apl add xs))

     mean
     ["given a seq of numbers, return the mean of it"
      (fn [xs] (div (..sum xs) (count xs)))]

     "returns a map of statistics concerning given numbers"
     (fn [& xs]
       {:xs xs
        :sum (.sum xs)
        :mean (.mean xs)})])
#+end_src

So you may have a question now :)
If hashmaps, vectors and strings have special semantics in =E+=,
How can I use them as normal values for my variables?!
The answer is the =:val= field.

#+begin_src clojure 
(E+ rawvals
    [h:val {:a 1 :b 2}
     v:val [1 2 3]
     s:val "iop"])

(is {:a 1 :b 2} rawvals.h)
(is "iop" rawvals.s)
#+end_src

One thing that may have intrigued you is relative environment member accesses. 
e.g =.sum=, =.mean= and =..sum= (in the stats previous definition)

#+begin_src clojure 
(E+ relative-access
    {demo1
     {a
      (fn []
        ;; we are resolving b and c in the parent module
        (add ..b ..c))
      b 1
      c 2}

     demo2
     {:val
      (fn [x]
        ;; the :val field is at the current module level
        ;; so we only need one dot here (meaning, 'in the current module')
        (add .b .c x))
      b 3
      c 4}

     demo3
     (fn [x]
       (add (..demo2 x)
            ;; relative dotted
            ..demo1.c))})

(is (relative-access.demo1.a) 3)
(is (relative-access.demo2 5) 12)
(is (relative-access.demo3 9) 18)
#+end_src

You may wonder about interop... it is not supported for now, more thinking is required on that matter.
At those early stages I tought that the core design is the main focus,
Asparagus is not at the get-the-things-done stage for now ;)

** Bubbling resolution

Using absolute and relative paths for all our vars is kind of painfull and ugly.
Sometimes it is needed to desambiguate but certainely not all the time.
When a symbol cannot be resolved at the current level, it will be searched bubling up the environment.

#+begin_src clojure 

(E+ bubling.demo
    {a 1
     b.c
     (fn []
       ;; here 'a will be resolved bubling up the environment
       ;; in this case it will be resolved to bubling.demo.a
       a)
     c
     {a 2
      b
      (fn []
        ;; here it will be resolved to bubling.demo.c.a
        a)}}
    )

(is 1 (bubling.demo.b.c))
(is 2 (bubling.demo.c.b))

#+end_src

** Links

The =:links= attribute let you define shorter accesses to other modules or members.
When a non relative symbol cannot be resolved at the current location,
its first segment will be searched in the current module links.
If there is an existant link it will be substituted by it.
If there is no link at the current level, we go up (bubling) and loop, until root.

#+begin_src  clojure

(E+ links.demo
    {mod1 {a 1 b 2 c {d 3 e 4}} ;; a bunch of things that we will link to

     mod2
     {:links {m1 links.demo.mod1
              m1c links.demo.mod1.c
              bub bubling.demo} ;; <- defined in previous section
      f
      (fn []
        ;; here m1.a will be substituted by links.demo.mod1.a
        ;; and m1c.d by links.demo.mod1.c.d
        (add m1.a m1c.d bub.a))}})

(is (links.demo.mod2.f) 5)

;; with this we can acheive some of the things we do with :require and :use in clojure ns's form
;; it will not be oftenly used directly, but will be used under the hood by higher level macros...

(E- links.demo)

#+end_src
 
** E-

You can remove global environment's members with =E-=

#+begin_src  clojure 

(E-
 foo bar baz my.module
 stats myval myvar rawvals relative-access bubling.demo links.demo)

;; it no longer exists
(isnt (env.get @E 'relative-access))

#+end_src

* Data Primitives

** Literals

literals works the same way as clojure ones (except for some extensions that will be explained later)

#+begin_src clojure
{:a 1}
[1 2 3]
'(1 2 3)
#{1 2}
"hello"
:iop
'mysym
\A
42
1.8
1e-7
#+end_src

** Collections

*** Constructor functions

Compared to clojure, the API have been uniformized

#+begin_src clojure
(is (vec 1 2 3) [1 2 3])
(is (lst 1 2 3) '(1 2 3))
(is (set 1 2 3) #{1 2 3})
(is (map [:a 1] [:b 2]) {:a 1 :b 2})
#+end_src

With sequential last argument (like =core/list*=).

#+begin_src clojure 
(is (vec* (lst 1 2 3 4)) ;; with one argument it behaves like core.vec
    (vec* 1 2 [3 4])
    [1 2 3 4]) 

(is (lst* [1 2 3 4])
    (lst* 1 2 [3 4])
    (lst* 1 2 3 4 [])
    '(1 2 3 4))

(is #{1 2 3 4}
    (set* 1 2 [3 4]))

(is (map* [:a 1] [:b 2] {:c 3 :d 4})
    (map* [:a 1] [[:b 2] [:c 3] [:d 4]])
    {:a 1 :b 2 :c 3 :d 4})
#+end_src

*** preds

Each collection have its pred, that returns the given collection on success or nil otherwise.

#+begin_src clojure
(is (vec? [1 2 3]) [1 2 3])
(is (lst? (lst 1 2 3)) (lst 1 2 3))
(is (set? #{1 2 3}) #{1 2 3})
(is (map? {:a 1}) {:a 1})
#+end_src

We will see that in asparagus we avoid predicates (functions that returns booleans)
in favor of guards (functions that can return nil indicating failure, or data).
For instance (pos? 1) may be, more useful if it returns 1 in case of success and nil otherwise.
This way it can be composed more easily I think.
More on control flow, shortcircuiting and stuff later...

** Words

*** Constructors 

Symbols and keywords have their core/str(ish) construtors

#+begin_src clojure 
(is (sym "foo") 'foo)
(is (key "foo") :foo)

(is (sym :foo "bar") 'foobar)
(is (key "foo" :bar "baz") :foobarbaz)
#+end_src

**** Star variants

#+begin_src clojure
(is (sym* "ab" (lst "cd" "ef" "gh"))
      'abcdefgh)
(is (key* "my" :keyword "_" [:foo :bar "baz"])
    :mykeyword_foobarbaz)
(is (str* "mystr_" ["a" "b"])
    "mystr_ab")
#+end_src

*** Guards

As for collections, we use guards instead of preds

#+begin_src clojure
(is (sym* "ab" (lst "cd" "ef" "gh"))
    'abcdefgh)
(is (key* "my" :keyword "_" [:foo :bar "baz"])
    :mykeyword_foobarbaz)
(is (str* "mystr_" ["a" "b"])
    "mystr_ab")
#+end_src

* Joining

** joining things together with =+=

As I mentioned in the rational, core operations are generic functions that can be extended. 
=+= is one of them

#+begin_src clojure
(is (+ [1 2] '(3 4))
    [1 2 3 4])

(is (+ (lst 1 2) [3 4])
    '(1 2 3 4))

(is (+ {:a 1 :b 0} {:b 2})
    {:a 1 :b 2})

;; + is variadic
(is (+ #{} (lst 1 2) [3 4] #{3 5})
    #{1 2 3 4 5})
#+end_src

As you have seen, the return type is determined by the first argument

*** strs syms and keywords

#+begin_src clojure
(is (+ 'foo "bar") 'foobar)
(is (+ :foo 'bar) :foobar)
(is (+ "foo" 'bar :baz) "foobar:baz")
#+end_src

*** functions 

On function it do composition (left to right, not like core.comp do)

#+begin_src clojure
(is ((+ inc inc (p mul 2)) 0)
    4)
#+end_src

** =sip= add one or several element into something

#+begin_src clojure 
(is (sip [] 1 2)
    [1 2])
#+end_src

For lists it adds at the end (not like conj do)
It is a choice that can be discutable, in my own pratice i'm not realying often on way that clojure lists implements conj
=sip= being a generic operation (extendable by user types) we could add a datatype that conj elements at its head like clojure lists...

#+begin_src clojure
(is (sip (lst 1 2) 3)
    '(1 2 3))

(is (sip #{3 4} 1 2)
    #{1 2 3 4})
#+end_src

For maps it works on entries

#+begin_src clojure 
(is (sip {:a 1} [:b 2] [:c 3])
    {:a 1 :b 2 :c 3})
#+end_src

For function it partially apply given args
(i'm not sure it should behave that way, it's more like an experimental fantasy that is not used in core code)

#+begin_src clojure
(is ((sip add 1 2) 3)
    6)
#+end_src


** =pure= returns the empty version of the given argument


#+begin_src clojure
(is (pure "foobar") "")

(is (pure {:a 1 :b 2}) {})

(is (pure inc) id)
#+end_src

Like =sip= and =+=, =pure= is a generic operation that can be implemented by user types

** =pure?= test for purity

#+begin_src clojure
(is {} (pure? {}))

(isnt (pure? {:a 1}))
#+end_src

* Composing

** Vectors 

#+begin_src clojure
(let [a 1
      b 2
      c [3 4]
      d [5 6]]

  ;; with a dot you can do splicing
  (is [a b . c] [1 2 3 4])
  ;; the spliced part can be anywhere
  (is [a b . c b a] [1 2 3 4 2 1])
  ;; several spliced parts
  (is [a b . c . d] [1 2 3 4 5 6])
  ;; shortcut (everything after the double dot is spliced)
  (is [a b .. c d] [1 2 3 4 5 6])
  ;; nested
  (is [a b [42 . d] . c]
      [1 2 [42 5 6] 3 4]))
#+end_src

** Maps

#+begin_src clojure
(let [a {:a 1}
      b {:b 2}
      c [1 2 3]]

  (is {:a 1
       :c 3
       . b} ;; we are merging b into the host map

      ;; if you want to splice several map into your literal use .. []
      {:c 3
       .. [a b]}

      {:a 1 :b 2 :c 3})

  ;; it can be nested

  (is
   {:foo [0 . c 4] ;; a composite vector
    :bar {:baz 1 . b}
    . a}

   {:foo [0 1 2 3 4]
    :bar {:baz 1 :b 2}
    :a 1})
  )
#+end_src

** Lists 

#+begin_src clojure
(let [nums [2 3 4]]

  ;; in conjunction with 'lst you can do the same things that we have shown with vectors
  (is (lst 1 . nums)
      (lst 1 2 3 4))

  ;; but more interesting is this
  ;; you can achieve apply semantics with dot notation
  (is (add 1 . nums)
      (c/apply add 1 nums)
      10)

  ;; but unlike with apply it does not have to be the last argument that is a collection
  (is (add 1 . nums 5) 15)

  ;; we have doubledot also
  (is (add .. nums nums nums)
      (add . nums . nums . nums)
      27)
  )
#+end_src

* Binding

Asparagus has a whole family of let like binding forms.
But unlike clojure's one, the binding behavior can be extended by the user in several ways.

** Let

Basic usage (nothing new)

#+begin_src clojure
(is (let [a 1] a)
    1)

(is (let [a 1 b 2] (add a b))
    3)

;; refer earlier binding
(is (let [a 1 b a] (add a b))
    2)
#+end_src

Binding symbols can be prepended by special character to indicate special behavior

*** Shortcircuiting bindings

If a binding symbol is prefixed by ?,
It has to bind to a not nil value else the whole let form is shortcircuited and return nil

#+begin_src clojure
(isnt (let [?a nil ;; this binding fail, therefore the next line will never be evaluated
               b (error "never evaluated")] 42))
#+end_src

*** Strict bindings

Binding symbol's prepended by ! must bind to non nil value, else an error is thrown.

#+begin_src clojure
(is :catched
     (try (let [!a (pos? -1)] :never)
          (catch Exception _ :catched)))
#+end_src

Those three modes of binding (regular (non prefixed symbols), shortcircuited, strict) can be combined inside let forms.
Resulting, i think, in much expressivity
  
** Let variants

*** =?let= (shortcircuiting let)

Is behaving like =let=, but the ? prefix is implicit to all binding symbols.

#+begin_src clojure
(?let [a 1 b 2] (add a b))
#+end_src

Is equivalent to

#+begin_src clojure
(let [?a 1 ?b 2] (add a b))
#+end_src

We can use strict bindings in a =?let= form, it will behave as in =let=.

#+begin_src clojure
(is :catched
    (try (?let [a 1
                !b (pos? -1)] (add a b))
         (catch Exception _ :catched)))
#+end_src

If we want to allow regular bindings (as normal symbols in a classic =let=)
We use the _ prefix:

#+begin_src clojure
(is (?let [a 1
           _b nil] ;; _b is bound to nil but this does not shorts
          a)
    1)
#+end_src

*** =!let= (strict let)

Is like =?let= but with implicit prefix !, it support ? and _ prefixes

#+begin_src clojure
(is :catched
      (try (!let [a nil] :never)
           (catch Exception _ :catched)))
#+end_src

*** =lut=

In a unified let, all symbols that appears several times have to bind to the same value (equal values)
otherwise it will shortcircuits

#+begin_src clojure
(is (lut [a 1 a (dec 2)] :success)
    :success)

(isnt
 (lut [a 1
       a 2] ;; this will shorts because a is already bound to 1
      (error "never thrown")))
#+end_src

*** =!lut= (unified strict let)

#+begin_src clojure
(is :catched
      (try (!lut [a 1
                  a 2] ;; this will throw because a is already bound to 1
                 :never)
           (catch Exception _ :catched)))
#+end_src

** Destructuration 

*** Literals


Like clojure's let we support destructuration
But unlike clojure, destructuration is an extensible mecanism
The user can define its own destructuration special forms

**** Sequential patterns

Using a vector in pattern position do the same as clojure (at first glance)

#+begin_src clojure
(is (let [[a b] [1 2]] {:a a :b b})
    {:a 1 :b 2})
#+end_src

But it is more strict
This does not pass because the seed and the pattern have different length 

#+begin_src clojure
(isnt (let [[a b c] [1 2]] :ok)
          (let [[a b] [1 2 3]] :ok))
#+end_src

Rest pattern

#+begin_src clojure
(is (let [[x . xs] (range 5)] [x xs])
    [0 (range 1 5)])
#+end_src

In clojure the following is valid
  
#+begin_src clojure
(clojure.core/let [[a b] [1 2 3]] {:a a :b b}) ;; {:a 1 :b 2}
#+end_src
 
The equivalent in asparagus should be written like this
   
#+begin_src clojure
(is (let [[a b . _] (range 10)] {:a a :b b}) ;; with the . _ we allow extra elements
    {:a 0 :b 1})
;; This way lambda argument patterns and let patterns behaves the same, which seems like a good thing
#+end_src 

Preserves collection type

#+begin_src clojure
(is (let [[x . xs] (vec 1 2 3)] [x xs])
    [1 [2 3]]) ;; in clojure [2 3] would be a seq
#+end_src

Post rest pattern
In clojure the rest pattern has to be the last binding, here we can bind the last element easily
 
#+begin_src clojure
(is (let [[x . xs lastx] (range 6)] [x xs lastx])
    [0 (range 1 5) 5])

;; (we could also have bound several things after the rest pattern)
(is (let [[x . xs y1 y2 y3] (range 6)] [x xs y1 y2 y3])
    [0 (lst 1 2) 3 4 5])
#+end_src


**** Map patterns

#+begin_src clojure
(is (let [{:a aval :b bval} {:a 1 :b 2 :c 3}] [aval bval])
    [1 2])
#+end_src
   
In clojure the same is acheived like this (I don't really understand why)
 
#+begin_src clojure
(c/let [{aval :a bval :b} {:a 1 :b 2 :c 3}] [aval bval])
#+end_src   

Maps have rest patterns to

#+begin_src clojure
(is (let [{:a aval . xs} {:a 1 :b 2 :c 3}] [aval xs])
    [1 {:b 2 :c 3}])
#+end_src   

As you may think, all binding modes are supported in destructuration bindings forms
    
*** Operators 

=ks= is a builtin binding operator
it behaves like clojure's :keys

#+begin_src clojure
(is (let [(ks a b) {:a 1 :b 2 :c 3}] (add a b))
    3)
#+end_src

In a =?let= form it shorts on nil keys

#+begin_src clojure
(isnt (?let [(ks a) {}] (error "never"))) 
#+end_src

=opt-ks= for keys that may not be here

#+begin_src clojure
(is "foo"
    (?let [(ks-opt foo) {:foo "foo"}] foo))

(exp @E '(let [{:foo _foo} {}] (or foo "foo")))
#+end_src

=ks-or= let you define default values for missing keys

#+begin_src clojure
(is "default"
    (?let [(ks-or foo "default") {}] foo))
;; you can use previous binding in further expressions
(is "Bob Doe"
    (?let [(ks-or firstname "John"
                  lastname "Doe"
                  fullname (+ firstname " " lastname)) ;; <- here
           {:name "Bob"}]
          fullname))
#+end_src

=&= (parrallel bindings)
several patterns can be bound to the same seed
something that i've sometimes missed in clojure (lightly)

#+begin_src clojure
(is (?let [(& mymap
              (ks a b)
              (ks-opt c)
              (ks-or d 42))
           {:a 1 :b 2 :c 3}]
          [mymap a b c d])
    [{:a 1 :b 2 :c 3} 1 2 3 42])
#+end_src

=cons=

#+begin_src clojure
(is (let [(cons a b) [1 2 3]] [a b])
    [1 [2 3]])
#+end_src

=quote=

#+begin_src clojure
(is (let ['iop 'iop] :ok)
    :ok)
(is (let [['foo :bar . xs] '[foo :bar 1 2 3]] xs)
    [1 2 3])
(is :ok
    (let ['(add 1 2) (lst 'add 1 2)] :ok))
#+end_src

Some others builtin bindings exists, see source.

**** Defining new bindings operators

#+begin_src clojure
;; we can extend binding ops like this

;; as an exemple we are redefining the & operation
(E+ (bind.op+ ks [xs seed] ;; xs are the arguments passed to the operation, seed is the expr we are binding
              (bind (zipmap ($ xs keyword) xs) seed)))

;; when this operation is used
'(let [(ks a b) x] ...)

;; at compile time the implementation is called with args: '(a b) and seed: 'x
;; =>
'(bind {:a 'a :b 'b} 'x) ;; we are using the map impl of bind
;; =>
'[G__244129 x
  G__244128 (do.guards.builtins.map? G__244129)
  a (clojure.core/get G__244129 :a)
  b (clojure.core/get G__244129 :b)]

;; finally it is substituted in the original form
'(let [G__244129 x
       G__244128 (do.guards.builtins.map? G__244129)
       a (clojure.core/get G__244129 :a)
       b (clojure.core/get G__244129 :b)]
   ...)
#+end_src

*** Special Bindings

when an sexpr in found in binding position (left side of let bindings)
if it is not a binding operator call (like we've just seen =ks= and =&= for instance)
it can be what we call a =guard pattern=

**** Guard pattern

a =guard pattern= is an expression with a binding symbol as first argument

#+begin_src clojure
(is 1

    (?let [(pos? a) 1] ;; if 1 is pos then the return value of (pos? 1) which is 1 is bound to the symbol a
          a) ;;=> 1

    ;; we could have bound the input of the guard directly to a,
    ;; but binding the return value of the guard is letting you use guards as coercing functions, which seems nice

    ;; is equivalent to
    (?let [a 1
           a (pos? a)]
          a))
#+end_src

This can be a bit confusing I guess, but wait a minute. This syntax is firstly making sense with guards that returns their first argument unchanged in case of success.

In asparagus there is a semantic convention that first argument to any function is "the thing the function is working on".

In OO terms the first argument is the object ('this' or 'self'). Other arguments are just parametrizing the operation.

I think that observing this convention is payful because it ease function composition.

As a counterexample in Clojure we often have mix -> and ->> because some functions are "working on" their first argument (as in asparagus)  
and others (map,filter etc..) on the last, it result in less clear code i think.
  
With this in mind, the fact that we bound the return value of the guard to the symbol that is in first argument position ('object position' we could say) makes a little more sense I guess.
And last but not least, by behaving this way, guard patterns can serve as a way to coerce input data (seed) 
  
Disclaimer: someone that I trust has said to me that in the "data world" the convention is that the flowing data is the last argument, so... :)  

#+begin_src clojure
(is 4
    (?let [(gt a 3) 4] ;; guards can have more than one arg
          a))

(isnt
 (?let [(gt a 3) 2]              ;; shorts
       (error "never touched")))
#+end_src

**** Type guards

An sexpr starting with a type keyword (see asparagus.boot.types) indicates a type guard pattern

#+begin_src clojure
(is [1 2 3]
    (?let [(:vec v) [1 2 3]]
          v))

(isnt
 (?let [(:seq v) [1 2 3]]
       (error "never"))) ;;=> nil
#+end_src

*** Value Patterns

Any value can be used in pattern position,

#+begin_src clojure
(is :ok (let [a (inc 2)
              3 a] ;; 3 is in binding position, therefore the seed (a) is tested for equality against it, and it shorts if it fails
          :ok))

(isnt
 (let [a (inc 2)
       4 a]
   (error "never")))

;; some tests

(is :ok
    (let [42 42] :ok)
    (?let [42 42] :ok)
    (!let [42 42] :ok))

(isnt 
 (let [42 43] :ok)
 (?let [42 43] :ok))

(!! (throws (!let [42 43] :ok)))
#+end_src

** =clet= (Cased Let) 

=clet= is like a cascade =?let= (shrotcircuiting let) forms
it can be be compared to cond-let but is more powerful

#+begin_src clojure
(is (clet [x (pos? -1)] {:pos x}      ;first case
          [x (neg? -1)] {:neg x}      ;second case
          )
    {:neg -1})
#+end_src

Each binding block can have several bindings

#+begin_src clojure
(let [f (fn [seed]
          (clet [x (num? seed) x++ (inc x)] x++
                [x (str? seed) xbang (+ x "!")] xbang))]
  (is 2 (f 1))
  (is "yo!" (f "yo"))
  (isnt (f :pop)))
#+end_src

Default case 

#+begin_src clojure 
(is (clet [x (pos? 0) n (error "never touched")] :pos
          [x (neg? 0) n (error "never touched")] :neg
          :nomatch)
    :nomatch)
#+end_src

Strict version

#+begin_src clojure 
(throws
 (!clet [x (pos? 0)] :pos
        [x (neg? 0)] :neg))
#+end_src

Unified version 
#+begin_src clojure
(let [f (fn [seed]
          (clut [[a a] seed] :eq
                [[a b] seed] :neq))]
  (is :eq (f [1 1]))
  (is :neq (f [1 2])))
#+end_src

Unified Version 

#+begin_src clojure 
(let [x [:tup [1 2]]]
  (throws
   (!clut [[:wat a] x] :nop
          [(:vec vx) x [:tup [a a]] vx] :yep)))

(let [p [:point 0 2]]
  (clet [[:point x 0] p] :y0
        [[:point 0 y] p] :x0
        [[:point x y] p] [x y]))
#+end_src

** Loop

let can be given a name (here :rec) in order to loop

#+begin_src clojure
(is (let :rec [ret 0 [x . xs] (range 10)]
            (if (pure? xs) ret
                (rec (add ret x) xs)))
       36)
#+end_src



** =case= 


#+begin_src clojure
(let [x (range 12)]
  ;; try those values:  42 "iop" :pouet
  (case x
    (num? x) {:num x}         ;; first clause, x is a number
    (str? x) {:str x}         ;; second clause, x is a string
    [x . xs] {:car x :cdr xs} ;; third clause, x is sequential
    :nomatch))
#+end_src

=case= has its unified variant =casu=


#+begin_src clojure
(let [t (f [x]
           (casu x
                 [:point x 0] :y0
                 [:point 0 y] :x0
                 [:point (:num x) (:num x)] :twin
                 [:point (:num x) (:num y)] [x y]
                 :pouet))]
  (is :y0 (t [:point 1 0]))
  (is :x0 (t [:point 0 1]))
  (is :twin (t [:point 1 1]))
  (is [1 2] (t [:point 1 2]))
  (is :pouet (t [:point 1 "io"])))
#+end_src

There is also =!case= and =!casu= that throws if nothing match the input.

#+begin_src clojure
(let [x 1]
  (throws
   (!case x
          (str? x) :str
          (vec? x) :vec)))
#+end_src

With the help of =case_= we can rewrite the first exemple more concisely.

#+begin_src clojure
(let [t (case_
         [:point x 0] :y0
         [:point 0 y] :x0
         [:point (:num x) (:num y)] [x y]
         :pouet)]
  (and
   (eq :y0 (t [:point 1 0]))
   (eq :x0 (t [:point 0 1]))
   (eq [1 2] (t [:point 1 2]))
   (eq :pouet (t [:point 1 "io"]))))
#+end_src

We can put guard symbols in pattern position.

#+begin_src clojure
(case :zer ;42 ;'zer ;"iop"
  num? :num ;; is equivalent to: (num? x) :num
  str? :hey
  (:sym x) x
  :nope)

(let [t (case_
         num? _
         str? _
         :pouet)]
  [(t 1)
   (t "iop")
   (t :iop)])
#+end_src

* Lambdas 

** =f= (macro)

All the binding forms that we have seen so far have their lambda equivalent.

Regular monoarity lambda:

#+begin_src clojure
(let [fun (f [a b] (add a b))]
  (is 3 (fun 1 2)))
#+end_src

Variadic syntax:

#+begin_src clojure
(let [fun (f [x . xs] (add x . xs))]
  (is 10 (fun 1 2 3 4)))
#+end_src

All binding patterns are available:

#+begin_src clojure
(let [fun (f [x (ks a b)]
             (+ x {:a a :b b}))]
  (is (fun {:foo 1 :bar 2}
           {:a 1 :b 2 :c 3})
      {:foo 1, :bar 2, :a 1, :b 2}))

(let [fun (f [(& x [x1 . xs])
              (& y [y1 . ys])]
             {:x x :y y :cars [x1 y1] :cdrs [xs ys]})]
  (is
   (fun [1 2 3 4] [7 8 9])
   {:x [1 2 3 4],
    :y [7 8 9],
    :cars [1 7],
    :cdrs [[2 3 4] [8 9]]}))
#+end_src

Like =let=, different binding modes are available via prefix syntax.

#+begin_src clojure
(let [fun (f [!a ?b] (lst a b))] ;; a is mandatory, and b can short the execution
  (is (fun 1 2) (lst 1 2))
  (isnt (fun 1 nil))
  (throws (fun nil 2)))
#+end_src

For recursion, like =clojure/fn= we can give a name to a lambda (we use keyword litteral to indicate a name)

#+begin_src clojure
(let [g (f :mylambda [x . xs]
           (if-not (c/seq xs) x
                   (add x (mylambda . xs))))]
  (is (g 1 2 3 4) 10))
#+end_src

The same can be acheive with =rec=

#+begin_src clojure
(let [g (f [x . xs]
           (if-not (c/seq xs) x
                   (add x (rec . xs))))]
  (is (g 1 2 3 4) 10))
#+end_src

Like in scheme, binding pattern can be a simple symbol
this is the reason why we need keyword litteral to name lambdas (to disambiguate)

#+begin_src clojure
(let [g (f xs (add . xs))]
  (is (g  1 2 3 4) 10))
#+end_src

** Variants 

Like let, =f= has its binding mode variants, =?f=, =!f=

#+begin_src clojure
(let [fun (?f [(vec? a) (num? b)] ;; this is guard patterns (see previous section)
              (sip a b))]
  ;; the binding succeed
  (is (fun [1 2 3] 4) [1 2 3 4])
  ;; first arg is not a vector so it shorts
  (isnt (fun 1 2)))
#+end_src

And also unified variants: =fu= and =!fu=

#+begin_src clojure
(let [fun (fu [a b a] :ok)]
  (is (fun 1 0 1) :ok)
  (isnt (fun 1 2 3)))

(let [fun (!fu [a a] :ok)]
  (is (fun 1 1) :ok)
  (throws (fun 1 2)))
#+end_src

** Syntactic sugar

*** =f1= (arity 1 syntax)

Functions that takes one argument are so common that it deserves, i think, some syntactic sugar.

#+begin_src clojure
(let [double (f1 a (add a a))]
  (is (double 2) 4))
#+end_src

You can use any binding pattern:

#+begin_src clojure
(let [fun (f1 (:vec a) (+ a a))] ;; we use a type guard (check if the given arg is a vector)
  (is (fun [1 2 3]) [1 2 3 1 2 3])
  (isnt (fun 42)))
#+end_src

It has all the common variations: =!f1= =?f1= =!fu1= =fu1= that do what you should expect (if you have not skip previous parts of this file)

We also have f_ that is a bit more concise than f1, if you don't need destructuring.

#+begin_src clojure
(let [double (f_ (add _ _))]
  (is (double 2) 4))
#+end_src

It also have common variations, f_, ?f_ , !f_ (unification variants are useless here)

** =cf= (case lambda)

The =cf= macro is a bit like clojure's =fn=, it let's you define polyarity functions, but it benefits from all asparagus binding capabilities.

#+begin_src clojure
(let [fun (cf [a] 1
              [a b] 2
              [(:num a) b c . xs] :var1
              [a b c . d] :var2)]
  (is (fun "iop") 1)
  (is (fun 1 2) 2)
  (is (fun 1 2 3 4 5) :var1)
  (is (fun "iop" 1 2 3) :var2))
#+end_src

It can have several implementaion with the same arity.

#+begin_src clojure
(let [fun (cf [(num? a)] {:num a}
              [(str? a)] {:str a})]
  (is (fun 1) {:num 1})
  (is (fun "aze") {:str "aze"}))
#+end_src

Note that variadic cases must have the same length.

#+begin_src clojure
'(cf [x . xs] :one
     [x y . zs] :two) ;;compile time error

(cf [(:vec x) . xs] :one
    [(:num x) . xs] :two) ;; is ok
#+end_src

all previous variations are implemented: =!cf=, =?cf=, =cfu=, =!cfu=. maybe I should have considered =cf1=...

You may ask yourself what is the price for this expressivity. I've worked hard on compiling those forms into performant code, 
There is certainly a price for the shortcircuit, strict and unified binding modes, but probably not as high as you may expect.
Sometimes it is close to bare clojure's perfs.



* Iterables
** Basic

=car= (is like Lisp's car or clojure.core/first)
#+begin_src clojure
(is 1 (car (lst 1 2)))
(is 1 (car [1 2]))
(is [:a 1] (car {:a 1 :b 2}))
#+end_src

=cdr= (is like clojure.core/rest but preserve collection type)
#+begin_src clojure
(is (cdr [1 2 3]) [2 3])
(is (cdr (lst 1 2 3)) (lst 2 3))
(is (cdr {:a 1 :b 2 :c 3}) {:b 2 :c 3}) ;; on map it does not make much sense but...
#+end_src

=last=
#+begin_src clojure
(is 2 (last (lst 1 2)))
(is 2 (last [1 2]))
(is [:b 2] (last {:a 1 :b 2})) ;; same here...
#+end_src

=butlast= (is like clojure.core/butlast but preserve collection type)
#+begin_src clojure
(is (cdr [1 2 3]) [2 3])
(is (cdr (lst 1 2 3)) (lst 2 3))
(is (cdr {:a 1 :b 2 :c 3}) {:b 2 :c 3})
#+end_src

=take= (like clojure.core/take with arguments reversed and preserving collection type)
#+begin_src clojure
(is (take (lst 1 2 3) 2) (lst 1 2))
(is (take [1 2 3] 2) [1 2])
(is (take {:a 1 :b 2 :c 3} 2) {:a 1 :b 2})
#+end_src

=drop=
#+begin_src clojure
(is (drop (lst 1 2 3) 2) (lst 3))
(is (drop [1 2 3] 2) [3])
(is (drop {:a 1 :b 2 :c 3} 2) {:c 3})
#+end_src

=takend=
#+begin_src clojure
(is (takend (lst 1 2 3) 2) (lst 2 3))
(is (takend [1 2 3] 2) [2 3])
(is (takend {:a 1 :b 2 :c 3} 2) {:b 2 :c 3})
#+end_src

=dropend=
#+begin_src clojure
(is (dropend (lst 1 2 3) 2) (lst 1))
(is (dropend [1 2 3] 2) [1])
(is (dropend {:a 1 :b 2 :c 3} 2) {:a 1})
#+end_src

=rev=
#+begin_src clojure
(is (rev [1 2 3]) [3 2 1])
(is (rev (lst 1 2 3)) (lst 3 2 1))
#+end_src

=section= (select a subsection of a sequantial data structure)
#+begin_src clojure
(is (section [1 2 3 4 5 6] 2 5) [3 4 5])
(is (section (lst 1 2 3 4 5 6) 1 5) (lst 2 3 4 5))
#+end_src

=splat= (split a sequential datastructure at the given index)
#+begin_src clojure
(is (splat [1 2 3 4] 2) [[1 2] [3 4]])
(is (splat (lst 1 2 3 4) 2) [(lst 1 2) (lst 3 4)])
#+end_src

=uncs= (uncons)
#+begin_src clojure
(is (uncs [1 2 3]) [1 [2 3]])
(is (uncs (lst 1 2 3)) [1 (lst 2 3)])
#+end_src

=runcs=
#+begin_src clojure
(is (runcs [1 2 3]) [[1 2] 3])
(is (runcs (lst 1 2 3)) [(lst 1 2) 3])
#+end_src

=cons=
#+begin_src clojure
(is (cons 1 [2 3]) [1 2 3])
(is (cons 1 (lst 2 3)) (lst 1 2 3))
;; it can take more arguments
(is (cons 0 1 [2 3]) [0 1 2 3])
(is (cons 1 2 3 (lst)) (lst 1 2 3))
#+end_src

** =map=, =reduce= and friends

*** =$= (map)

Following the first argument convention we mentioned earlier,  =map= is taking the object as first argument.

#+begin_src clojure
(is ($ [0 1 2] inc)
    [1 2 3])
#+end_src

It preserves collection type

#+begin_src clojure
(is ($ #{1 2 3} inc)
    #{2 3 4})
#+end_src

On maps it behaves differently from =clojure.core/map=, given functions are receiving only the values.

#+begin_src clojure
(is ($ {:a 1 :b 2} inc)
    {:a 2 :b 3})
#+end_src

*** =$i= (map-indexed)

#+begin_src clojure
(is ($i [:a :b :c] (f [idx val] {:idx idx :val val}))
    [{:idx 0, :val :a}
     {:idx 1, :val :b}
     {:idx 2, :val :c}])
#+end_src

on maps it receives key-value pairs, given functions has to return only the value

#+begin_src clojure
(is ($i {:a 1 :b 2}
        (f [idx val]
           ;; we return the key-value pair as is
           [idx val]))
    ;; the key-value pair has been put in value position
    ;; the keys cannot be altered with $i,
    ;; if you think about it $i on a vector or sequence cannot alter indexes,
    ;; map keys are like unordered indexes somehow, so it seems to be the correct behavior
    {:a [:a 1], :b [:b 2]})
#+end_src

With sets, given functions receives a twin pair, which seems logical as sets can be viewed as maps with twin entries.
It is pointless to use $i explicetly on a set, but in a ploymorphic context, sets have to have a meaningful implementation.

#+begin_src clojure
(is ($i #{:a :b :c}
        ;; the same function we use above in the map exemple
        (f [idx val] [idx val]))
    #{[:a :a] [:b :b] [:c :c]})
#+end_src

so now you may wonder about what we leave behing from the clojure.core/map behavior, in particular, core/map can takes several sequences.

*** =zip=

#+begin_src clojure
(c/map + (range 10) (range 10)) ;;=> (0 2 4 6 8 10 12 14 16 18)
#+end_src

In asparagus there is another function for that called =zip=. 
Zipping several iterables together using the given function.

#+begin_src clojure
(is (zip add (range 10) (range 10))
    (lst 0 2 4 6 8 10 12 14 16 18))
#+end_src

Like =core.map= it is variadic.
#+begin_src clojure
(is (zip add (range 10) (range 10) (range 10) (range 10))
    (lst 0 4 8 12 16 20 24 28 32 36))
#+end_src

*** =$+=

=$+= is to =$= what =mapcat= is to =map=

#+begin_src clojure
(is ($+ (range 6) (f_ (c/repeat _ _)))
    (lst 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5))

(is ($+ [[3 2 1 0] [6 5 4] [9 8 7]] rev)
    [0 1 2 3 4 5 6 7 8 9])
#+end_src

*** =$i+= 

indexed version of =$+=

#+begin_src clojure
(is ($i+ [[3 2 1 0] [6 5 4] [9 8 7]]
         (f [i v] (cons [:idx i] (rev v))))
    [[:idx 0] 0 1 2 3 [:idx 1] 4 5 6 [:idx 2] 7 8 9])
#+end_src

*** =zip+=

#+begin_src clojure
(is (zip+ (f [a b]
             (c/sort
              ;; set+ makes a set from several collections
              (set+ a b)))
          [[3 1 0] [6 5] [9 8 7]]
          [[3 2 0] [5 4] [9 7]])
    (lst 0 1 2 3 4 5 6 7 8 9))
#+end_src

while writing this i'm considering zipi and zipi+...

*** =red=

=red= is like =core/reduce= but with different argument order and variadic arity.
=red= takes the 'seed as first argument (because it is the data we are working on, we are following the convention), a reducing function as second argument and (unlike clojure.core/reduce) as many iterables as you like (here one).

#+begin_src clojure
(is (red #{} sip [1 2 3 3 4 2 1 5 6 4 5]) ;; 'sip is asparagus conj(ish) function
    #{1 4 6 3 2 5})
#+end_src

With several iterables

#+begin_src clojure
(is (red []
         (f [ret a b] ;; note that the reducing function arity is dependant on the number of given iterables (here two)
            (sip ret (add a b)))
         [1 2 3 4]
         [2 3 4 5])
    [3 5 7 9])
#+end_src

*** =filt= and =rem=

#+begin_src clojure
(is [1 2 3]  (filt [1 2 -1 -2 3] num? pos?))
(is [-1 -2] (rem [1 2 -1 -2 3] pos?))
#+end_src

** =iter=, =idxs= and =vals=

Under the hood many of the functions described in the previous section rely on those three basics operations.

*** =iter= 

Is like core/seq (but do not returns nil on empty things).

#+begin_src clojure
(is (iter {:a 1 :b 2})
    (lst [:a 1] [:b 2]))
(is (iter [1 2 3])
    (lst 1 2 3))
(is (iter (lst 1 2 3))
    (lst 1 2 3))
#+end_src

*** =vals= 

Returns a seq of values in the given argument.

#+begin_src clojure
(is (vals {:a 1 :b 2})
    (lst 1 2))
(is (vals [1 2 3])
    (lst 1 2 3))
(is (vals (lst 1 2 3))
    (lst 1 2 3))
#+end_src

*** =idxs=

Returns a seq of keys for maps, or a seq of idexes for sequentials.

#+begin_src clojure
(is (idxs {:a 1 :b 2})
    (lst :a :b))
(is (idxs [1 2 3])
    (lst 0 1 2))
(is (idxs (lst 1 2 3))
    (lst 0 1 2))
#+end_src

those three functions are generic and can be implemented for your types

** Extra operations 

=scan= (like core/partition)
#+begin_src clojure
(is [[1 2] [3 4]]
    (scan [1 2 3 4] 2 2))
(is [[1 2] [2 3] [3 4]]
    (scan [1 2 3 4] 2 1))
(is '((0 1 2 3) (2 3 4))
    (scan (c/range 5) 4 2))
#+end_src

=chunk=
#+begin_src clojure
(is [[1 2] [3]]
    (chunk [1 2 3] 2))
(is []
    (chunk [] 2))
#+end_src

=braid= (like core/interleave)
#+begin_src clojure
(is '(1 4 2 5 3 6)
    (braid [1 2 3] [4 5 6]))
(is '(1 4 2 5)
    (braid [1 2 3] [4 5]))
#+end_src

=nths=
#+begin_src clojure
(is (nths (range 10) 3)
    (lst 0 3 6 9))
#+end_src

=car= and =cdr= compositions, like in scheme we have those little facilities, this is the main reason I chose car/cdr over first/rest.
#+begin_src clojure
(is :io
    (cadr [1 :io])
    (caddr [1 2 :io])
    (caadr [1 [:io 2] 3])
    (cadadr [1 [2 :io]]))
#+end_src

** Walking

=depth first=
#+begin_src clojure
(!! (dfwalk [1 2 {:a 1 :b [1 2 3]}] p/prob))
#+end_src

=breadth first=
#+begin_src clojure
(!! (bfwalk [1 2 {:a 1 :b [1 2 3]}] p/prob))
#+end_src

=walk?=
#+begin_src clojure
(!! (walk? [1 2 {:a 1 :b [1 2 3]}]
           coll? ;; this is call on each node, in order to decide to walk deeper or not
           p/prob ;; when the above fails on a node, this one is called on it
           ))
#+end_src

* Functional Programing

One thing we all love in functional programming is the ability to compose functions together.
Manipulating them easily, passing them to other functions, partially apply them etc... 
In asparagus I've tried to push all those things further than clojure.

** Application, Invocation

Application and invocation are generic function that can be implemented for any type.
Those operations are so central in functional programming that i've decided to give them really short symbols.

- =*= for application
- =§= for invocation

*** =§= (invocation)

for function it is trivial.

#+begin_src clojure
(is (§ add 1 2)
    3)
#+end_src

For constants it returns itself.

#+begin_src clojure
(is (§ 42 "iop") 42)
(is (§ "pouet" 1 2 3) "pouet")
#+end_src


Datastructures have their invocation implementation, that differs from clojure, it does not perform a get.

Some exemples should speak by themselves:

**** Vectors

#+begin_src clojure
(is (§ [inc dec] [0 0])
    [1 -1])
#+end_src

You can nest invocables several level deep, it will do what you expect

#+begin_src clojure
(is (§ [inc dec [inc dec :foo]] [0 0 [0 0 0]])
    [1 -1 [1 -1 :foo]])
#+end_src

But wait you can feed several arguments too!

#+begin_src clojure
(is (§ [add sub add] [1 2 3] [1 2 3] [1 2 3])
    [3 -2 9])
#+end_src

It leaves extra indexes as is.

#+begin_src clojure
(is (§ [inc dec] [0 1 2 3])
    [1 0 2 3])
#+end_src

**** Maps

#+begin_src clojure
(is (§ {:a inc :b dec :c [inc dec]}
     {:a 0 :b 0 :c [0 0]})
    {:a 1 :b -1 :c [1 -1]})
#+end_src

several args:

#+begin_src clojure
(is (§ {:a add :b sub}
     {:a 1 :b 2}
     {:a 1 :b 2})
    {:a 2 :b 0})
#+end_src

Extra keys are left as is:

#+begin_src clojure
(is (§ {:a inc}
     {:a 0 :b 0})
    {:a 1 :b 0})
#+end_src

If extra keys are present in several args the last is kept.
#+begin_src clojure
(is (§ {:a add} {:a 1 :b 2} {:a 1 :b 7})
    {:a 2 :b 7})
#+end_src

** The "object" convention

In asparagus, many functions takes what we can call the object as first argument.

I mean, the thing we are working on, for instance, in the expression (assoc mymap :a 1 :b 2), mymap is what we call the object. 

All functions that can be viewed this way, will always take the 'object' as first argument.

With this simple convention we can achieve a regularity that yield to easier function composition.

The argumentation function will help to turn this kind of function into a one that takes only the arguments (in the previous exemple: :a 1 :b 2) and return a function that takes only the target object, and return the result.

#+begin_src clojure
(let [assoc_ (argumentation:val assoc)
      assoc-a-and-b (assoc_ :a 1 :b 2)]
  (assoc-a-and-b {}))
#+end_src

You can also pass arguments immediatly.
#+begin_src clojure
(let [f (argumentation assoc :a 1)]
  (f {}))
#+end_src

many of the asparagus functions that follow this convention, have their argumentation version with the same name suffixed with _.

This is handy, for instance, to create chains of 1 argument functions.

#+begin_src clojure
(is (> (range 10) (drop_ 3) (dropend_ 2)) ;; will thread '(range 10) thru 2 functions, the semantics is analog to core/-> but it is a function
    (range 3 8))
#+end_src

the =>= function is defined in the :invocation-application-mapping section of =asparagus.core=

It will return a function that wait for its first argument ('myseq in the previous example)

#+begin_src clojure
(!! (>_ (take_ 3) (dropend_ 2)))
#+end_src

** Guards

One other thing that ease function composition is what I call guards (for lack of better name)
Guards differs from predicate by the fact that they can either return nil or something (in most case the given 'object' unchanged) so they can be used like predicates, but do not stop the flowing data, therefore they can be chained via function composition.

some examples of guards:
#+begin_src clojure
(is (vec? [1 2]) [1 2])
(isnt (vec? (lst 1 2)))
(is (pos? 1) 1)
(isnt (pos? -1))
#+end_src

As we've seen we can chain them like this.
#+begin_src clojure
(let [g (>_ num? pos? (gt_ 2))] ;; gt is greater-than
  (is 3 (g 3)))
;; but + does the same
(let [g (+ num? pos? (gt_ 2))]
  (is 3 (g 3)))
#+end_src

*** Collection guards

**** =$?=

check if all values of a datastructure are not nil (see 'iterables section)

#+begin_src clojure
(is ($? [1 2 3])
    [1 2 3])

(isnt ($? [1 nil 2 3]))

(is ($? {:a 1 :b 2})
    {:a 1 :b 2})

(isnt ($? {:a 1 :b nil}))
#+end_src

**** =?$=

=?$= is a composition of =$= and =$?=

It can be viewed as a map operation that succed if all values of the resulting collection are non nil

#+begin_src clojure
(is (?$ [2 3 4 5] num? inc (gt_ 2))
    [3 4 5 6])

(isnt (?$ [3 4 1 5] num? inc (gt_ 2)))
#+end_src


**** =?zip= 

the zip variant

#+begin_src clojure
(is (?zip #(pos? (add %1 %2)) [1 2 3] [1 2 3])
    (lst 2 4 6))

(isnt (?zip #(pos? (add %1 %2)) [1 2 3] [1 2 -3]))
#+end_src

**** =?deep=

a deep variant of =?$=, checks if all nested values are non =nil=

#+begin_src clojure
(check
 (nil? (?deep {:a {:b 1 :c [1 2 nil]}}))
 (nil? (?deep {:a {:b 1 :c [1 2 3 {:d nil}]}}))
 ;; succeed
 (?deep {:a {:b 1 :c [1 2 3]}}))
#+end_src

*** Creating Guards

#+begin_src clojure
(let [g (guard.unary c/odd?)]
  (is 1 (g 1)))

(let [g (guard.binary c/>=)]
  (is 2 (g 2 1)))

(let [g (guard.variadic c/>=)]
  (is 8 (g 8 8 7 6 5 2)))

;; or simply
(let [g (guard:fn c/>=)]
  (is 8 (g 8 8 7 6 5 2)))
#+end_src

**** the =guard= macro

It has the same syntax than the f macro but the resulting function will return the first argument unchanged if its body succeeds, otherwise nil

#+begin_src clojure
(let [g (guard [x] (odd? (count x)))]
  (is (g [1 2 3]) [1 2 3])
  (isnt (g [1 2 3 4])))
#+end_src


**** wrapping and importing predicates 

#+begin_src clojure
(E+ (guards.import [odd? 1] [even? 1]))

(is 1 (odd? 1))
(isnt (even? 1))
#+end_src

** Control Flow

*** =?>=

Thread the object thru guards shorting on first nil result.

#+begin_src clojure
(is 1 (?> 1 num? pos?))
(isnt (?> 1 num? neg?))
#+end_src

Shorts after str? (else it would be an error).

#+begin_src clojure
(isnt (?> 1 str? (+_ "aze")))
#+end_src

More exemples:

#+begin_src clojure
(is 3 (?> [1 2 3] (guard:fn (+ c/count c/odd?)) last))
(isnt (?> [1 2] (guard [x] ((+ c/count c/odd?) x)) last))

#+end_src

More composed exemple:

=?>= use =§= under the hood, so anything that implement invocation is allowed.

#+begin_src clojure
(is (?> -1
        num? ;;=> -1
        (c/juxt (add_ -2) (add_ 2)) ;;=> [-3 1]
        [neg? (?>_ num? pos?)] ;; using _ version
        )
    [-3 1])
#+end_src

*** =?<=

Trying all given guards against x until first non nil result.

#+begin_src clojure
(is 1 (?< 1 coll? num?))
(isnt (?< 1 str? coll? sym?))
#+end_src

Build a guard that succeed for numbers or strings.

#+begin_src clojure
(let [f (?<_ num? str?)]
  (is [1 "a" nil]
      [(f 1) (f "a") (f :a)]))
#+end_src

Basic composition with =?<= and =?>_=:
#+begin_src clojure
(is 42
    (?< 44
        str?
        (?>_ num? (gt_ 10) dec dec)))
#+end_src

*** =?c=

A clojure-cond(ish) function.

#+begin_src clojure
(is 2
    (?c 1
        ;; like clojure cond
        ;; works by couples
        str? :pouet ;; if str? succeed :pouet is called
        pos? inc
        neg? dec))

(is 10
    (?c 10
        num? (lt_ 3) ;; if the second pred fail, we go to next couple
        num? (gt_ 7) ;; this line succeed
        ))
#+end_src

(non function values act as constant functions).

#+begin_src clojure
(is :pouet
    (?c "a"
        str? :pouet
        pos? inc
        neg? dec))
#+end_src

Same with =?c_=

#+begin_src clojure
(is -2
    (let [f (?c_
             str? :pouet
             pos? inc
             neg? dec)]
      (f -1)))
#+end_src

*** =?c>=

A scheme-cond(ish) function.

#+begin_src clojure
(is -8
    (?c> -2
         ;; like scheme cond
         ;; several vecs of guards
         [str? :pouet]
         [pos? inc inc inc]
         [neg? dec dec (p mul 2)]))

(is :1
    (?c> 1
         ;; here too, if the line does not succeed entirely,
         ;; skip to the next line
         [pos? dec pos? :gt1]
         [pos? :1]))

(is 5
    (let [f (?c>_
             [str? :pouet]
             [pos? inc inc inc]
             [neg? dec dec (p mul 2)])]
      (f 2)))
#+end_src

*** =df= 

data function:

create a function from a data structure that apply all functions contained in it (deeply) to further args while preserving its original structure.

you can use vectors and maps to compose the resulting function

#+begin_src clojure
(!! (df [inc
         dec
         {:doubled (f_ (mul 2 _))
          :halfed (f_ (div _ 2))}])) ;;=> <fn>
#+end_src

Invoc it:
#+begin_src clojure
(let [f (df [inc dec
             {:doubled (f_ (mul 2 _))
              :halfed (f_ (div _ 2))}])]
  (is (f 1)
      [2 0 {:doubled 2 :halfed 1/2}]))

;; is equivalent to write
((f1 a [(inc a) (dec a)
        {:doubled (mul 2 a)
         :halfed (div a 2)}])
 1)
#+end_src

Any invocable can serve as a leaf. Don't know if you remember, but in asparagus almost everything is invocable.
In particular constant values like 42 or :foo return themselves. To demonstrate that df can handle any invocable, we will use some of those.

#+begin_src clojure
(let [f (df [inc dec :foo 42])]
  (is (f 1)
      [2 0 :foo 42]))
#+end_src

Can take several arguments.
#+begin_src clojure
(let [f (df [add sub])]
  (is (f 1 2 3)
      [6 -4]))
#+end_src

You can deeply mix maps and vecs to compose your function.
#+begin_src clojure
(let [f (df {:addsub [add sub]
             :average (f xs (div (* add xs) (count xs)))})]
  (is (f 1 2 3)
      {:addsub [6 -4], :average 2}))
#+end_src

Maybe you are wondering about our vec and map invocation behavior. This is prevented here because vecs and maps mean something else in this context.
But you can use the =§= function to state that a leaf that is a map or a vec has to be treated as an invocable.

#+begin_src clojure
(let [f (df [concat
             (§ [add sub mul]) ;; here
             ])]
  (is (f [1 2 3] [4 5 6])
      ['(1 2 3 4 5 6) [5 -3 18]]))
#+end_src

*** Composing data flow 

with guards, shortcircuiting binding/lambda forms (?let, clet, cf, ?f...) , invocable datastructures, data functions, conditional functions (?c and ?c>), guard connectors (?< and ?>)

#+begin_src clojure
(is

 (?> ["foo" 0]
     ;; with invocable data we can go inside the flowing data
     [
      ;; we check if the first idx is a :word (str, sym or keyword),
      ;; if yes cast it to keyword
      (?>_ word? key)

      ;; with data functions we can do sort of the opposite (wrapping instead of going inside)
      ;; (here we receiving 0 and returning {:val 0, :inc 1, :dec -1}
      (df {:val id :++ inc :-- dec})]

                                        ;p/prob

     (case_ [:bar x] {:bar x}
            [:foo (& x (ks val))] ;; we check that data idx 0 is :foo, and that the idx 1 has a :val key
            (case val
              pos? {:positive-foo x}
              neg? {:negative-foo x}
              {:zero-foo x})
            (id x) {:fail x})

                                        ;p/prob

     (?c_ (?f1 {:fail x}) (f_ (pp "fail: " _) _) ;; shortcircuiting lambdas can be useful in those contexts
          (?f1 {:zero-foo x}) (f_ (pp "zero-foo " _) _)
          (f_ (pp "num-foo " _) _))

     )

 {:zero-foo {:val 0, :++ 1, :-- -1}})
#+end_src


#+begin_src clojure
#+end_src

#+begin_src clojure
#+end_src

#+begin_src clojure
#+end_src

#+begin_src clojure
#+end_src

#+begin_src clojure
#+end_src

#+begin_src clojure
#+end_src

#+begin_src clojure
#+end_src
